#!/usr/bin/env node

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  Tool,
} from "@modelcontextprotocol/sdk/types.js";
import * as dotenv from "dotenv";
import path from "path";
import { fileURLToPath } from "url";
import axios from 'axios';
import * as fs from 'fs';
import FormData from 'form-data';

// Configure dotenv to load from local .env file
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
dotenv.config({ path: path.resolve(__dirname, '..', '.env') });

// API Keys from environment variables
const VT_API_KEY = process.env.VT_API_KEY!;
const HA_API_KEY = process.env.HA_API_KEY!;

if (!VT_API_KEY || !HA_API_KEY) {
  console.error("Error: VT_API_KEY and HA_API_KEY environment variables are required");
  process.exit(1);
}

// Tool definitions
const VIRUSTOTAL_SCAN_TOOL: Tool = {
  name: "virustotal_scan",
  description: 
    "Scans a file using VirusTotal's API to detect malware and other threats. " +
    "Provides detailed analysis from multiple antivirus engines. " +
    "Returns scan results including detection statistics.",
  inputSchema: {
    type: "object",
    properties: {
      file_path: {
        type: "string",
        description: "Path to the file to scan"
      }
    },
    required: ["file_path"]
  }
};

const HYBRID_ANALYSIS_TOOL: Tool = {
  name: "hybrid_analysis_scan",
  description: 
    "Performs dynamic analysis of files using Hybrid Analysis sandbox environment. " +
    "Provides detailed behavioral analysis and threat detection. " +
    "Returns comprehensive analysis report including system behavior.",
  inputSchema: {
    type: "object",
    properties: {
      file_path: {
        type: "string",
        description: "Path to the file to scan"
      },
      environment_id: {
        type: "number",
        description: "Environment ID for analysis (default: 140 - Windows 10 64-bit)",
        default: 140
      }
    },
    required: ["file_path"]
  }
};

// VirusTotal Implementation
interface VTUploadResponse {
  data: {
    id: string;
  };
}

interface VTAnalysisStats {
  harmless: number;
  malicious: number;
  suspicious: number;
  undetected: number;
  timeout: number;
}

interface VTAnalysisResponse {
  data: {
    attributes: {
      status: 'queued' | 'in-progress' | 'completed';
      stats: VTAnalysisStats;
    };
  };
}

async function scanWithVirusTotal(filePath: string): Promise<string> {
  try {
    // Upload file
    const form = new FormData();
    form.append('file', fs.createReadStream(filePath));

    const uploadResponse = await axios.post<VTUploadResponse>(
      'https://www.virustotal.com/api/v3/files',
      form,
      {
        headers: {
          ...form.getHeaders(),
          'x-apikey': VT_API_KEY,
        },
      }
    );

    const analysisId = uploadResponse.data.data.id;
    console.log(`✅ File uploaded to VirusTotal. Analysis ID: ${analysisId}`);

    // Poll for results
    const url = `https://www.virustotal.com/api/v3/analyses/${analysisId}`;
    let attempts = 0;
    const maxAttempts = 30; // 5 minutes maximum wait time

    while (attempts < maxAttempts) {
      const response = await axios.get<VTAnalysisResponse>(url, {
        headers: { 'x-apikey': VT_API_KEY },
      });

      const { status, stats } = response.data.data.attributes;

      if (status === 'completed') {
        return `VirusTotal Scan Results:
- Malicious: ${stats.malicious}
- Suspicious: ${stats.suspicious}
- Harmless: ${stats.harmless}
- Undetected: ${stats.undetected}
- Timeout: ${stats.timeout}

View full results at: https://www.virustotal.com/gui/file/${analysisId}`;
      }

      console.log('⏳ VirusTotal scan in progress... retrying in 10 seconds');
      await new Promise(resolve => setTimeout(resolve, 10000));
      attempts++;
    }

    return "VirusTotal scan timed out after 5 minutes. Please check results manually using the analysis ID: " + analysisId;
  } catch (error: any) {
    throw new Error(`VirusTotal scan failed: ${error.response?.data?.error?.message || error.message}`);
  }
}

// Hybrid Analysis Implementation
interface HASubmissionResponse {
  job_id: string;
  sha256: string;
}

interface HADetailedReport {
  summary?: any;
  state?: string;
}

async function scanWithHybridAnalysis(filePath: string, environmentId: number = 140): Promise<string> {
  try {
    // Upload file
    const form = new FormData();
    form.append('file', fs.createReadStream(filePath));
    form.append('environment_id', environmentId.toString());

    const uploadResponse = await axios.post<HASubmissionResponse>(
      'https://www.hybrid-analysis.com/api/v2/submit/file',
      form,
      {
        headers: {
          ...form.getHeaders(),
          'api-key': HA_API_KEY,
          'User-Agent': 'Hybrid-Analysis-MCP-Server',
        },
      }
    );

    const { job_id, sha256 } = uploadResponse.data;
    console.log(`✅ File submitted to Hybrid Analysis. Job ID: ${job_id}`);

    // Wait for initial analysis
    await new Promise(resolve => setTimeout(resolve, 5000));

    // Get analysis results
    let attempts = 0;
    const maxAttempts = 30; // 5 minutes maximum wait time

    while (attempts < maxAttempts) {
      try {
        const response = await axios.get(
          `https://www.hybrid-analysis.com/api/v2/report/${job_id}/summary`,
          {
            headers: {
              'api-key': HA_API_KEY,
              'User-Agent': 'Hybrid-Analysis-MCP-Server',
            },
          }
        );

        return `Hybrid Analysis Results:
- Analysis complete
- SHA256: ${sha256}
- View full results at: https://www.hybrid-analysis.com/sample/${sha256}

Summary:
${JSON.stringify(response.data, null, 2)}`;
      } catch (error) {
        console.log('⏳ Hybrid Analysis scan in progress... retrying in 10 seconds');
        await new Promise(resolve => setTimeout(resolve, 10000));
        attempts++;
      }
    }

    return "Hybrid Analysis scan timed out after 5 minutes. Please check results manually using SHA256: " + sha256;
  } catch (error: any) {
    throw new Error(`Hybrid Analysis scan failed: ${error.response?.data?.message || error.message}`);
  }
}

// Server implementation
const server = new Server(
  {
    name: "malware-scan",
    version: "0.1.0",
  },
  {
    capabilities: {
      tools: {},
    },
  },
);

// Tool handlers
server.setRequestHandler(ListToolsRequestSchema, async () => ({
  tools: [VIRUSTOTAL_SCAN_TOOL, HYBRID_ANALYSIS_TOOL],
}));

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  try {
    const { name, arguments: args } = request.params;

    if (!args || typeof args !== "object") {
      throw new Error("No arguments provided");
    }

    switch (name) {
      case "virustotal_scan": {
        if (!("file_path" in args) || typeof args.file_path !== "string") {
          throw new Error("Invalid file_path argument");
        }
        const results = await scanWithVirusTotal(args.file_path);
        return {
          content: [{ type: "text", text: results }],
          isError: false,
        };
      }

      case "hybrid_analysis_scan": {
        if (!("file_path" in args) || typeof args.file_path !== "string") {
          throw new Error("Invalid file_path argument");
        }
        const environmentId = ("environment_id" in args && typeof args.environment_id === "number") 
          ? args.environment_id 
          : 140;
        const results = await scanWithHybridAnalysis(args.file_path, environmentId);
        return {
          content: [{ type: "text", text: results }],
          isError: false,
        };
      }

      default:
        return {
          content: [{ type: "text", text: `Unknown tool: ${name}` }],
          isError: true,
        };
    }
  } catch (error) {
    return {
      content: [
        {
          type: "text",
          text: `Error: ${error instanceof Error ? error.message : String(error)}`,
        },
      ],
      isError: true,
    };
  }
});

async function runServer() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("Malware Scan MCP Server running on stdio");
}

runServer().catch((error) => {
  console.error("Fatal error running server:", error);
  process.exit(1);
}); 